<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Try Again Gaming - The Only Online Casino That's 100% Free Forever</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a;
            color: #e2e8f0;
        }
        .game-container, .stats-modal-content {
            background-color: #1e293b;
            border: 1px solid #334155;
        }
        .stat-box {
            background-color: #334155;
        }
        .btn {
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }
        .btn-primary {
            background-color: #2563eb;
            color: white;
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #1d4ed8;
        }
        .btn-primary:disabled {
            background-color: #475569;
            cursor: not-allowed;
        }
        .btn-secondary {
            background-color: #4ade80;
            color: #1e293b;
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: #22c55e;
        }
        .btn-secondary:disabled {
            background-color: #475569;
            cursor: not-allowed;
        }
        .btn-danger {
            background-color: #ef4444;
            color: white;
        }
        .btn-danger:hover {
            background-color: #dc2626;
        }
        .input-field {
            background-color: #0f172a;
            border: 1px solid #475569;
            color: #e2e8f0;
        }
        .multiplier-display {
            font-size: 3rem;
            font-weight: 900;
            position: absolute;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            text-shadow: 0 0 10px rgba(0,0,0,0.7);
        }
        .game-tab {
            background-color: #334155;
            color: #94a3b8;
        }
        .game-tab.active {
            background-color: #4f46e5;
            color: white;
        }
        #minesGrid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
        }
        .mine-tile {
            width: 100%;
            aspect-ratio: 1 / 1;
            background-color: #475569;
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .mine-tile:hover {
            transform: scale(1.05);
        }
        .mine-tile.revealed {
            cursor: default;
            transform: scale(0.95);
        }
        .mine-tile.gem {
            background-color: #10b981;
        }
        .mine-tile.mine {
            background-color: #ef4444;
        }
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.7);
        }
        #diceResultDisplay, #limboResultDisplay {
            font-size: 3rem;
            font-weight: 700;
            transition: color 0.3s;
        }
        .stats-table {
            width: 100%;
            border-collapse: collapse;
        }
        .stats-table th, .stats-table td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid #334155;
        }
        .stats-table th {
            background-color: #334155;
        }
        .card {
            background-color: white;
            color: black;
            border-radius: 6px;
            width: 60px;
            height: 90px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        }
        .card.red { color: #ef4444; }
        .card.hidden { background-color: #94a3b8; }
        .hand-container {
            display: flex;
            gap: 8px;
            min-height: 100px;
            align-items: center;
        }
        #kenoGrid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
        }
        .keno-tile {
            background-color: #475569;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            text-align: center;
            padding: 4px 0;
            font-size: 0.8rem;
        }
        .keno-tile.selected {
            background-color: #4f46e5;
        }
        .keno-tile.hit {
            background-color: #10b981;
        }
        .keno-tile.miss {
            background-color: #ef4444;
            opacity: 0.5;
        }
        #slideReelContainer {
            overflow: hidden;
            position: relative;
            height: 120px;
            width: 100%;
        }
        #slideReel {
            display: flex;
            height: 100%;
            position: absolute;
            left: 0;
            transition: left 4s cubic-bezier(0.25, 0.1, 0.25, 1);
        }
        .slide-item {
            width: 100px;
            height: 100px;
            margin: 10px 5px;
            border-radius: 8px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.5rem;
            color: white;
        }
        #slidePointer {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 100%;
            background-color: white;
            z-index: 10;
        }
        .risk-btn {
             background-color: #334155;
        }
        .risk-btn.active {
            background-color: #4f46e5;
        }
        /* New Styles for Auto-Bet and History */
        .bet-mode-tab {
            background-color: #334155;
            color: #94a3b8;
            border: 1px solid #475569;
            border-bottom: none;
        }
        .bet-mode-tab.active {
            background-color: #1e293b;
            color: white;
            border-color: #334155;
            border-bottom: 1px solid #1e293b;
            margin-bottom: -1px;
        }
        .bet-controls-container {
            border: 1px solid #334155;
            background-color: #1e293b;
        }
        .live-history-bar {
            display: flex;
            gap: 6px;
            overflow-x: auto;
            padding: 8px 4px;
            margin-top: 12px;
            border-top: 1px solid #334155;
            scrollbar-width: thin;
            scrollbar-color: #475569 #1e293b;
        }
        .history-item {
            flex-shrink: 0;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
            background-color: #475569;
            color: #e2e8f0;
            cursor: pointer;
            min-width: 70px;
            text-align: center;
        }
        .history-item.win {
            background-color: #10b981;
            color: #1e293b;
        }
        .history-item.loss {
            background-color: #ef4444;
            color: #ffffff;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl mx-auto">
    <h1 class="text-4xl font-bold text-center mb-2 text-slate-200">Try Again Gaming</h1>
    <p class="text-center text-slate-400 mb-6">The Only Online Casino That's 100% Free Forever</p>

        <!-- Stats Display -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6 text-center">
            <div class="stat-box p-4 rounded-lg">
                <h2 class="text-sm font-semibold text-slate-400 uppercase">Current Cash</h2>
                <p id="currentCash" class="text-2xl font-bold text-green-400">$100.00</p>
            </div>
            <div class="stat-box p-4 rounded-lg">
                <h2 class="text-sm font-semibold text-slate-400 uppercase">Account</h2>
                <div id="accountInfo" class="text-left">
                    <div id="accountName" class="text-lg font-bold text-slate-200">Not logged in</div>
                    <div id="accountLevel" class="text-sm text-slate-400">Level: 0</div>
                    <div class="w-full bg-slate-700 h-2 rounded mt-2 overflow-hidden">
                        <div id="accountXpBar" class="h-2 bg-green-400" style="width:0%"></div>
                    </div>
                    <div id="accountXpText" class="text-xs text-slate-400 mt-1">XP: 0</div>
                </div>
            </div>
            <div class="stat-box p-4 rounded-lg">
                <h2 class="text-sm font-semibold text-slate-400 uppercase">Run Time</h2>
                <p id="runTime" class="text-2xl font-bold">00:00</p>
            </div>
        </div>

        <!-- Game Area -->
        <div id="gameArea" class="game-container p-6 rounded-lg shadow-lg hidden">
            <!-- Game Tabs -->
            <div class="flex flex-wrap space-x-1 mb-4 text-xs md:text-base">
                <button class="game-tab flex-1 p-2 rounded-md font-semibold btn active" data-game="crash">Crash</button>
                <button class="game-tab flex-1 p-2 rounded-md font-semibold btn" data-game="limbo">Limbo</button>
                <button class="game-tab flex-1 p-2 rounded-md font-semibold btn" data-game="mines">Mines</button>
                <button class="game-tab flex-1 p-2 rounded-md font-semibold btn" data-game="dice">Dice</button>
                <button class="game-tab flex-1 p-2 rounded-md font-semibold btn" data-game="blackjack">Blackjack</button>
                <button class="game-tab flex-1 p-2 rounded-md font-semibold btn" data-game="keno">Keno</button>
                <button class="game-tab flex-1 p-2 rounded-md font-semibold btn" data-game="slide">Slide</button>
            </div>

            <!-- Game Displays -->
            <div id="crashGame" class="game-display">
                <div class="relative flex flex-col items-center justify-center h-64 bg-slate-900/50 rounded-lg border border-slate-700 p-4">
                    <canvas id="crashChart"></canvas>
                    <p id="multiplier" class="multiplier-display text-slate-200">1.00x</p>
                </div>
                <div id="crashHistory" class="live-history-bar"></div>
            </div>
            <div id="limboGame" class="game-display hidden">
                <div class="flex flex-col items-center justify-center h-64 bg-slate-900/50 rounded-lg border border-slate-700 p-4 space-y-4">
                    <div id="limboResultDisplay" class="text-slate-200">--.--x</div>
                </div>
                <div id="limboHistory" class="live-history-bar"></div>
            </div>
            <div id="minesGame" class="game-display hidden">
                 <div class="flex flex-col items-center justify-center h-auto bg-slate-900/50 rounded-lg border border-slate-700 p-4">
                    <div class="w-full max-w-xs" id="minesGrid"></div>
                </div>
                <div id="minesHistory" class="live-history-bar"></div>
            </div>
            <div id="diceGame" class="game-display hidden">
                <div class="flex flex-col items-center justify-center h-auto bg-slate-900/50 rounded-lg border border-slate-700 p-4 space-y-4">
                    <div id="diceResultDisplay" class="text-slate-500">--.--</div>
                    <div class="w-full max-w-md">
                        <input id="diceSlider" type="range" min="1" max="9999" value="5000" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="flex justify-between w-full max-w-md text-sm">
                        <div><span class="font-semibold text-slate-400">Multiplier:</span> <span id="diceMultiplier" class="font-bold text-white">2.00x</span></div>
                        <div><span class="font-semibold text-slate-400">Win Chance:</span> <span id="diceWinChance" class="font-bold text-white">50.00%</span></div>
                    </div>
                </div>
                <div id="diceHistory" class="live-history-bar"></div>
            </div>
            <div id="blackjackGame" class="game-display hidden">
                <div class="flex flex-col items-center justify-center h-auto bg-slate-900/50 rounded-lg border border-slate-700 p-4 space-y-4">
                    <div>
                        <h3 class="text-center font-bold">Dealer's Hand (<span id="dealerScore">0</span>)</h3>
                        <div id="dealerHand" class="hand-container"></div>
                    </div>
                     <div>
                        <h3 class="text-center font-bold">Your Hand (<span id="playerScore">0</span>)</h3>
                        <div id="playerHand" class="hand-container"></div>
                    </div>
                </div>
                <div id="blackjackHistory" class="live-history-bar"></div>
            </div>
             <div id="kenoGame" class="game-display hidden">
                <div class="flex flex-col md:flex-row items-start justify-center gap-4 h-auto bg-slate-900/50 rounded-lg border border-slate-700 p-4">
                    <div id="kenoGrid" class="flex-grow"></div>
                    <div id="kenoPayouts" class="w-full md:w-48 text-xs bg-slate-800 p-2 rounded"></div>
                </div>
                <div id="kenoHistory" class="live-history-bar"></div>
            </div>
            <div id="slideGame" class="game-display hidden">
                 <div class="flex flex-col items-center justify-center h-48 bg-slate-900/50 rounded-lg border border-slate-700">
                    <div id="slideReelContainer">
                        <div id="slideReel"></div>
                        <div id="slidePointer"></div>
                    </div>
                </div>
                <div id="slideHistory" class="live-history-bar"></div>
            </div>
            
            <div class="text-center mt-2 mb-4">
                <p id="gameMessage" class="text-lg text-center text-slate-400 mb-1 h-8">&nbsp;</p>
                <p id="xpMessage" class="text-sm text-center text-green-400 h-5">&nbsp;</p>
            </div>

            <!-- Controls -->
            <div class="flex space-x-2 -mb-px">
                <button id="manualBetTab" class="bet-mode-tab active px-4 py-2 rounded-t-md font-semibold">Manual</button>
                <button id="autoBetTab" class="bet-mode-tab px-4 py-2 rounded-t-md font-semibold">Auto</button>
            </div>
            <div class="bet-controls-container p-4 rounded-b-md rounded-tr-md">
                <!-- Manual Bet Controls -->
                <div id="manualBetControls">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label for="betAmount" class="block text-sm font-medium mb-1 text-slate-400">Bet Amount</label>
                            <input type="number" id="betAmount" value="10" class="input-field w-full p-3 rounded-md shadow-inner">
                            <div id="limboControls" class="mt-2 hidden">
                                 <label for="limboTarget" class="block text-sm font-medium mb-1 text-slate-400">Target Multiplier</label>
                                 <input type="number" id="limboTarget" value="2.00" step="0.01" min="1.01" class="input-field w-full p-3 rounded-md shadow-inner">
                                 <div class="text-sm mt-1 text-slate-400">Win Chance: <span id="limboWinChance" class="font-bold text-white">49.50%</span></div>
                            </div>
                            <div id="minesControls" class="mt-2 hidden">
                                 <label for="mineCount" class="block text-sm font-medium mb-1 text-slate-400">Mines (1-24)</label>
                                 <input type="number" id="mineCount" value="5" min="1" max="24" class="input-field w-full p-3 rounded-md shadow-inner">
                            </div>
                            <div id="diceControls" class="mt-2 hidden">
                                <button id="diceBetTypeBtn" class="w-full btn bg-green-600 text-white font-bold py-2 rounded-md">Roll Under 50.00</button>
                            </div>
                            <div id="blackjackControls" class="mt-2 hidden flex space-x-2">
                                <button id="hitBtn" class="w-full btn bg-yellow-500 text-slate-900 font-bold py-2 rounded-md">Hit</button>
                                <button id="standBtn" class="w-full btn bg-blue-500 text-white font-bold py-2 rounded-md">Stand</button>
                            </div>
                            <div id="slideControls" class="mt-2 hidden">
                                <label class="block text-sm font-medium mb-1 text-slate-400">Risk Level</label>
                                <div class="flex space-x-2">
                                    <button class="risk-btn btn flex-1 active" data-risk="easy">Easy</button>
                                    <button class="risk-btn btn flex-1" data-risk="medium">Medium</button>
                                    <button class="risk-btn btn flex-1" data-risk="hard">Hard</button>
                                    <button class="risk-btn btn flex-1" data-risk="expert">Expert</button>
                                </div>
                            </div>
                        </div>
                        <div class="flex flex-col space-y-2">
                             <button id="placeBetBtn" class="w-full btn btn-primary font-bold py-3 rounded-md">Place Bet</button>
                             <button id="cashOutBtn" class="w-full btn btn-secondary font-bold py-3 rounded-md" disabled>Cash Out</button>
                        </div>
                    </div>
                </div>

                <!-- Auto Bet Controls -->
                <div id="autoBetControls" class="hidden">
                     <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <!-- Column 1: Core Settings -->
                        <div class="space-y-3">
                             <div>
                                <label for="autoBetAmount" class="block text-xs font-medium mb-1 text-slate-400">Base Bet</label>
                                <input type="number" id="autoBetAmount" value="1.00" class="input-field w-full p-2 rounded-md shadow-inner text-sm">
                            </div>
                             <div>
                                <label for="autoNumBets" class="block text-xs font-medium mb-1 text-slate-400">Number of Bets (0=inf)</label>
                                <input type="number" id="autoNumBets" value="0" min="0" class="input-field w-full p-2 rounded-md shadow-inner text-sm">
                            </div>
                        </div>
                        <!-- Column 2: Win/Loss Actions -->
                        <div class="space-y-3">
                            <div>
                                <label for="autoOnWin" class="block text-xs font-medium mb-1 text-slate-400">On Win: Increase By (%)</label>
                                <div class="flex items-center">
                                    <input type="number" id="autoOnWinValue" value="0" class="input-field w-full p-2 rounded-l-md shadow-inner text-sm">
                                    <button id="autoResetOnWin" class="btn bg-slate-600 px-3 py-2 text-xs rounded-r-md">Reset</button>
                                </div>
                            </div>
                             <div>
                                <label for="autoOnLoss" class="block text-xs font-medium mb-1 text-slate-400">On Loss: Increase By (%)</label>
                                 <div class="flex items-center">
                                    <input type="number" id="autoOnLossValue" value="100" class="input-field w-full p-2 rounded-l-md shadow-inner text-sm">
                                    <button id="autoResetOnLoss" class="btn bg-slate-600 px-3 py-2 text-xs rounded-r-md">Reset</button>
                                </div>
                            </div>
                        </div>
                         <!-- Column 3: Limits & Action -->
                        <div class="space-y-3 flex flex-col">
                             <div>
                                <label for="autoStopOnProfit" class="block text-xs font-medium mb-1 text-slate-400">Stop on Profit ($)</label>
                                <input type="number" id="autoStopOnProfit" value="0" min="0" class="input-field w-full p-2 rounded-md shadow-inner text-sm">
                            </div>
                             <div>
                                <label for="autoStopOnLoss" class="block text-xs font-medium mb-1 text-slate-400">Stop on Loss ($)</label>
                                <input type="number" id="autoStopOnLoss" value="0" min="0" class="input-field w-full p-2 rounded-md shadow-inner text-sm">
                            </div>
                            <button id="startAutoBetBtn" class="w-full btn btn-primary font-bold py-2 rounded-md mt-auto">Start Auto Bet</button>
                        </div>
                     </div>
                </div>
            </div>

             <div class="mt-6 flex justify-center space-x-4">
                <button id="viewStatsBtn" class="btn bg-indigo-600 hover:bg-indigo-700 font-bold py-3 px-8 rounded-md">View Stats</button>
                <button id="endRunBtn" class="btn btn-danger font-bold py-3 px-8 rounded-md">End Run</button>
            </div>
            
            <!-- Live Stats Bar -->
            <div class="mt-6 pt-4 border-t border-slate-700 flex justify-around text-center">
                <div>
                    <h3 class="text-sm font-semibold text-slate-400 uppercase">Run Profit</h3>
                    <p id="liveProfit" class="text-lg font-bold text-green-400">$0.00</p>
                </div>
                 <div>
                    <h3 class="text-sm font-semibold text-slate-400 uppercase">Bets Placed</h3>
                    <p id="liveBets" class="text-lg font-bold">0</p>
                </div>
                <div>
                    <h3 class="text-sm font-semibold text-slate-400 uppercase">Win Rate</h3>
                    <p id="liveWinRate" class="text-lg font-bold">N/A</p>
                </div>
            </div>
        </div>
        
        <!-- Login Page (shown first) -->
        <div id="loginPage" class="text-center p-6">
            <h2 class="text-2xl font-bold mb-3">Welcome to Try Again Gaming</h2>
            <div class="mb-4">
                <input id="loginUsernameInput" placeholder="Enter username" class="input-field p-3 rounded-md w-64" />
            </div>
            <div class="space-x-2">
                <button id="loginExistingBtn" class="btn btn-secondary font-bold py-2 px-4 rounded-md">Login</button>
                <button id="registerBtn" class="btn btn-primary font-bold py-2 px-4 rounded-md">Register New (will overwrite)</button>
            </div>
            <p class="text-sm text-slate-400 mt-3">Tip: Registering with an existing username will reset that account.</p>
        </div>

        <div id="startScreen" class="text-center p-6 space-x-4 hidden">
             <div>
                 <button id="startRunBtn" class="btn btn-primary font-bold py-4 px-10 rounded-lg text-xl">Start New Run</button>
                 <button id="lifetimeStatsBtn" class="btn bg-slate-600 hover:bg-slate-700 font-bold py-4 px-10 rounded-lg text-xl">View Account</button>
             </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="gameOverModal" class="fixed inset-0 items-center justify-center hidden modal-backdrop">
        <div class="bg-slate-800 p-8 rounded-lg shadow-2xl text-center max-w-sm mx-auto border border-slate-600">
            <h2 id="modalTitle" class="text-3xl font-bold mb-4">Run Over</h2>
            <p id="modalMessage" class="text-slate-300 mb-2"></p>
            <p class="text-lg mb-6">Final Score: <span id="finalScore" class="font-bold text-green-400"></span></p>
            <button id="playAgainBtn" class="btn btn-primary font-bold py-3 px-6 rounded-md">Play Again</button>
        </div>
    </div>

    <!-- Stats Modal -->
    <div id="statsModal" class="fixed inset-0 items-center justify-center hidden modal-backdrop p-4">
        <div class="stats-modal-content p-6 rounded-lg shadow-2xl w-full max-w-3xl mx-auto">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-3xl font-bold">Run Statistics</h2>
                <button id="closeStatsBtn" class="text-2xl font-bold">&times;</button>
            </div>
            <div class="mb-6">
                <h3 class="font-semibold mb-2">Profit Graph</h3>
                <div class="bg-slate-900 p-2 rounded"><canvas id="statsGraph" height="150"></canvas></div>
            </div>
            <table class="stats-table text-sm">
                <thead><tr><th>Game</th><th>W/L</th><th>Win Rate</th><th>Profit</th><th>Wagered</th></tr></thead>
                <tbody id="statsTableBody"></tbody>
            </table>
        </div>
    </div>

    <!-- Lifetime Stats Modal -->
    <div id="lifetimeStatsModal" class="fixed inset-0 items-center justify-center hidden modal-backdrop p-4">
        <div class="stats-modal-content p-6 rounded-lg shadow-2xl w-full max-w-3xl mx-auto">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-3xl font-bold">Account</h2>
                <button id="closeLifetimeStatsBtn" class="text-2xl font-bold">&times;</button>
            </div>
            <div id="accountDetails" class="mb-4">
                <h3 class="font-semibold">Account Summary</h3>
                <div id="accountSummaryBody" class="text-sm mt-2"></div>
            </div>
            <table class="stats-table text-sm">
                <thead><tr><th>Game</th><th>W/L</th><th>Win Rate</th><th>Profit</th><th>Wagered</th></tr></thead>
                <tbody id="lifetimeStatsTableBody"></tbody>
            </table>
        </div>
    </div>


    <script>
        // --- Sound System using Web Audio API ---
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const soundSystem = {
            enabled: true,
            volume: 0.5,
            
            // Generate a win sound (happy ascending beep)
            playWin(streak = 1) {
                if (!this.enabled) return;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.connect(gain);
                gain.connect(audioContext.destination);
                
                // Higher pitch and longer duration for streaks
                const baseFreq = 440 * (1 + (streak * 0.2)); // Pitch increases with streak
                const duration = 0.1 + (Math.min(streak, 5) * 0.05); // Longer for higher streaks
                
                osc.frequency.setValueAtTime(baseFreq, audioContext.currentTime);
                osc.frequency.linearRampToValueAtTime(baseFreq * 1.5, audioContext.currentTime + duration);
                
                gain.gain.setValueAtTime(0, audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(this.volume * 0.2, audioContext.currentTime + 0.01);
                gain.gain.exponentialRampToValueAtTime(this.volume * 0.05, audioContext.currentTime + duration);
                
                osc.start();
                osc.stop(audioContext.currentTime + 0.2);
            },
            
            // Generate a loss sound (low pitch sad beep)
            playLoss() {
                if (!this.enabled) return;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.connect(gain);
                gain.connect(audioContext.destination);
                
                osc.frequency.setValueAtTime(220, audioContext.currentTime);
                osc.frequency.linearRampToValueAtTime(110, audioContext.currentTime + 0.3);
                
                gain.gain.setValueAtTime(0, audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(this.volume * 0.2, audioContext.currentTime + 0.01);
                gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3);
                
                osc.start();
                osc.stop(audioContext.currentTime + 0.3);
            },
            
            // Generate a click sound for bets and UI
            playClick() {
                if (!this.enabled) return;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.connect(gain);
                gain.connect(audioContext.destination);
                
                osc.frequency.setValueAtTime(880, audioContext.currentTime);
                
                gain.gain.setValueAtTime(0, audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(this.volume * 0.1, audioContext.currentTime + 0.001);
                gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.05);
                
                osc.start();
                osc.stop(audioContext.currentTime + 0.05);
            },
            
            // Generate a tick sound for Limbo counter
            playTick(multiplier) {
                if (!this.enabled) return;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.connect(gain);
                gain.connect(audioContext.destination);
                
                // Higher pitch as multiplier increases
                const baseFreq = 300 + Math.min(700, multiplier * 100);
                osc.frequency.setValueAtTime(baseFreq, audioContext.currentTime);
                
                gain.gain.setValueAtTime(0, audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(this.volume * 0.03, audioContext.currentTime + 0.001);
                gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.05);
                
                osc.start();
                osc.stop(audioContext.currentTime + 0.05);
            },

            // Generate a ticking sound for Crash game
            playCrashTick(multiplier) {
                if (!this.enabled) return;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.connect(gain);
                gain.connect(audioContext.destination);
                
                osc.type = 'triangle'; // Softer than sine
                
                // Pitch increases slightly with multiplier
                const baseFreq = 500 + Math.min(800, multiplier * 15);
                osc.frequency.setValueAtTime(baseFreq, audioContext.currentTime);
                
                gain.gain.setValueAtTime(0, audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(this.volume * 0.06, audioContext.currentTime + 0.005);
                gain.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.06);
                
                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.06);
            },

            // Generate a level up celebration sound
            playLevelUp() {
                if (!this.enabled) return;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.connect(gain);
                gain.connect(audioContext.destination);
                
                osc.frequency.setValueAtTime(440, audioContext.currentTime);
                osc.frequency.linearRampToValueAtTime(880, audioContext.currentTime + 0.1);
                osc.frequency.setValueAtTime(587.33, audioContext.currentTime + 0.1);
                osc.frequency.linearRampToValueAtTime(880, audioContext.currentTime + 0.2);
                
                gain.gain.setValueAtTime(0, audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(this.volume * 0.2, audioContext.currentTime + 0.01);
                gain.gain.linearRampToValueAtTime(this.volume * 0.2, audioContext.currentTime + 0.2);
                gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3);
                
                osc.start();
                osc.stop(audioContext.currentTime + 0.3);
            },
            
            // Set volume (0-1)
            setVolume(vol) {
                this.volume = Math.max(0, Math.min(1, vol));
            },
            
            // Toggle sound on/off
            toggle() {
                this.enabled = !this.enabled;
                return this.enabled;
            }
        };

        // --- DOM Elements ---
        const currentCashEl = document.getElementById('currentCash');
    const accountNameEl = document.getElementById('accountName');
    const accountLevelEl = document.getElementById('accountLevel');
    const accountXpBarEl = document.getElementById('accountXpBar');
    const accountXpTextEl = document.getElementById('accountXpText');
        const runTimeEl = document.getElementById('runTime');
        const gameMessageEl = document.getElementById('gameMessage');
        const xpMessageEl = document.getElementById('xpMessage');
        const betAmountInput = document.getElementById('betAmount');
        const placeBetBtn = document.getElementById('placeBetBtn');
        const cashOutBtn = document.getElementById('cashOutBtn');
        const startRunBtn = document.getElementById('startRunBtn');
        const endRunBtn = document.getElementById('endRunBtn');
        const viewStatsBtn = document.getElementById('viewStatsBtn');
        const gameArea = document.getElementById('gameArea');
        const startScreen = document.getElementById('startScreen');
        const gameOverModal = document.getElementById('gameOverModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const finalScore = document.getElementById('finalScore');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const statsModal = document.getElementById('statsModal');
        const closeStatsBtn = document.getElementById('closeStatsBtn');
        const liveProfit = document.getElementById('liveProfit');
        const liveBets = document.getElementById('liveBets');
        const liveWinRate = document.getElementById('liveWinRate');
        const gameTabs = document.querySelectorAll('.game-tab');
        const gameDisplays = document.querySelectorAll('.game-display');
        const multiplierEl = document.getElementById('multiplier');
        const minesGridEl = document.getElementById('minesGrid');
        const mineCountInput = document.getElementById('mineCount');
        const minesControls = document.getElementById('minesControls');
        const diceControls = document.getElementById('diceControls');
        const diceSlider = document.getElementById('diceSlider');
        const diceMultiplierEl = document.getElementById('diceMultiplier');
        const diceWinChanceEl = document.getElementById('diceWinChance');
        const diceBetTypeBtn = document.getElementById('diceBetTypeBtn');
        const diceResultDisplay = document.getElementById('diceResultDisplay');
        const statsGraphCanvas = document.getElementById('statsGraph');
        const statsGraphCtx = statsGraphCanvas.getContext('2d');
    const statsTableBody = document.getElementById('statsTableBody');
        const blackjackControls = document.getElementById('blackjackControls');
        const hitBtn = document.getElementById('hitBtn');
        const standBtn = document.getElementById('standBtn');
        const dealerHandEl = document.getElementById('dealerHand');
        const playerHandEl = document.getElementById('playerHand');
        const dealerScoreEl = document.getElementById('dealerScore');
        const playerScoreEl = document.getElementById('playerScore');
        const kenoGridEl = document.getElementById('kenoGrid');
        const kenoPayoutsEl = document.getElementById('kenoPayouts');
        const lifetimeStatsBtn = document.getElementById('lifetimeStatsBtn');
        const lifetimeStatsModal = document.getElementById('lifetimeStatsModal');
        const closeLifetimeStatsBtn = document.getElementById('closeLifetimeStatsBtn');
        const lifetimeStatsTableBody = document.getElementById('lifetimeStatsTableBody');
        const slideControls = document.getElementById('slideControls');
        const slideReelContainer = document.getElementById('slideReelContainer');
        const slideReel = document.getElementById('slideReel');
        const slideRiskBtns = document.querySelectorAll('#slideControls .risk-btn');
        const crashChartCanvas = document.getElementById('crashChart');
        const limboControls = document.getElementById('limboControls');
        const limboTargetInput = document.getElementById('limboTarget');
        const limboWinChanceEl = document.getElementById('limboWinChance');
        const limboResultDisplay = document.getElementById('limboResultDisplay');

        // New Auto Bet DOM Elements
        const manualBetTab = document.getElementById('manualBetTab');
        const autoBetTab = document.getElementById('autoBetTab');
        const manualBetControls = document.getElementById('manualBetControls');
        const autoBetControls = document.getElementById('autoBetControls');
        const startAutoBetBtn = document.getElementById('startAutoBetBtn');
        const autoBetAmountInput = document.getElementById('autoBetAmount');
        const autoNumBetsInput = document.getElementById('autoNumBets');
        const autoOnWinValueInput = document.getElementById('autoOnWinValue');
        const autoResetOnWinBtn = document.getElementById('autoResetOnWin');
        const autoOnLossValueInput = document.getElementById('autoOnLossValue');
        const autoResetOnLossBtn = document.getElementById('autoResetOnLoss');
        const autoStopOnProfitInput = document.getElementById('autoStopOnProfit');
        const autoStopOnLossInput = document.getElementById('autoStopOnLoss');


    // --- Game State ---
    let state = {};
    let crashChart;

        // --- Timers and Intervals ---
        let runTimerInterval = null;
        let crashLoopInterval = null;
    let pausedTime = 0;
    let timeAtPause = 0;
        
        // --- Constants ---
    const BOMB_SVG = '<svg viewBox="0 0 24 24" fill="white" class="w-8 h-8"><path d="M12,2A10,10,0,1,0,22,12,10,10,0,0,0,12,2Zm0,18a8,8,0,1,1,8-8A8,8,0,0,1,12,20Z"/><path d="M16,4.47a1,1,0,0,0-1.15-.83l-2.4,0.8a1,1,0,0,0-.8,1.15l0.8,2.4A1,1,0,0,0,14,8.82a1,1,0,0,0,.85-0.38l2-2A1,1,0,0,0,16,4.47Z"/></svg>';
        const SLIDE_MULTIPLIERS = {
            easy:   [{m:0, w:30, c:'bg-slate-500'}, {m:0.1, w:20, c:'bg-slate-500'}, {m:0.2, w:15, c:'bg-slate-500'}, {m:0.5, w:10, c:'bg-green-500'}, {m:1.2, w:10, c:'bg-green-500'}, {m:1.5, w:8, c:'bg-blue-500'}, {m:2, w:7, c:'bg-blue-500'}],
            medium: [{m:0, w:50, c:'bg-slate-500'}, {m:0.2, w:15, c:'bg-green-500'}, {m:0.5, w:10, c:'bg-green-500'}, {m:1.5, w:10, c:'bg-blue-500'}, {m:3, w:8, c:'bg-blue-500'}, {m:5, w:5, c:'bg-purple-600'}, {m:20, w:2, c:'bg-purple-600'}],
            hard:   [{m:0, w:70, c:'bg-slate-500'}, {m:0.1, w:10, c:'bg-green-500'}, {m:2, w:8, c:'bg-blue-500'}, {m:5, w:5, c:'bg-purple-600'}, {m:10, w:4, c:'bg-purple-600'}, {m:25, w:2, c:'bg-yellow-500'}, {m:100, w:1, c:'bg-yellow-500'}],
            expert: [{m:0, w:94, c:'bg-slate-500'}, {m:5, w:2, c:'bg-purple-600'}, {m:20, w:1.5, c:'bg-yellow-500'}, {m:100, w:1, c:'bg-yellow-500'}, {m:500, w:0.9, c:'bg-yellow-500'}, {m:2000, w:0.5, c:'bg-pink-500'}, {m:10000, w:0.1, c:'bg-gradient-to-r from-pink-500 via-red-500 to-yellow-500'}]
        };


        // --- Utility Functions ---
        const formatCurrency = (value, sign = true) => {
            const signChar = value >= 0 ? '+' : '-';
            const absValue = Math.abs(value);
            return `${sign ? signChar : ''}$${absValue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
        };
        const formatTime = (seconds) => {
            const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
            const secs = (seconds % 60).toString().padStart(2, '0');
            return `${mins}:${secs}`;
        };

        // --- Core Game Logic ---
        function createEmptyStats() {
            return { wins: 0, losses: 0, wagered: 0, won: 0 };
        }

        function initializeRun() {
            pausedTime = 0;
            timeAtPause = 0;
            const previousAccount = state.account;
            state = {
                runActive: true,
                isPaused: false,
                currentCash: 100.00,
                maxCashReached: 100.00,
                runStartTime: Date.now(),
                gameInProgress: false,
                currentBet: 0,
                currentRoundBet: 0,
                currentGame: 'crash',
                crash: { multiplier: 1.00, crashPoint: 0, startTime: 0 },
                limbo: { target: 2.00 },
                mines: { grid: [], rows: 5, cols: 5, mineCount: 5, gemsFound: 0, payoutMultiplier: 1.0 },
                dice: { betType: 'under', target: 50.00, multiplier: 2.00, winChance: 50.00 },
                blackjack: { deck: [], playerHand: [], dealerHand: [], playerScore: 0, dealerScore: 0, status: 'betting' },
                keno: { selectedNumbers: [] },
                slide: { risk: 'easy' },
                runStats: {
                    cashHistory: [{ bet: 0, cash: 100.00 }],
                    overall: createEmptyStats(),
                    crash: createEmptyStats(),
                    limbo: createEmptyStats(),
                    mines: createEmptyStats(),
                    dice: createEmptyStats(),
                    blackjack: createEmptyStats(),
                    keno: createEmptyStats(),
                    slide: createEmptyStats(),
                },
                history: {
                    crash: [], limbo: [], mines: [], dice: [], blackjack: [], keno: [], slide: [],
                },
                autoBet: {
                    isActive: false,
                    baseBet: 1.00,
                    currentBet: 1.00,
                    numBets: 0,
                    betsMade: 0,
                    onWinIncrease: 0,
                    onLossIncrease: 100,
                    resetOnWin: true,
                    resetOnLoss: false,
                    stopOnProfit: 0,
                    stopOnLoss: 0,
                    sessionStartCash: 0,
                    sessionProfit: 0,
                }
            };
            // restore account if logged in
            if (previousAccount) state.account = previousAccount;
            startScreen.classList.add('hidden');
            gameArea.classList.remove('hidden');
            gameOverModal.classList.add('hidden');
            gameOverModal.classList.remove('flex');
            switchGame('crash');
            startRunTimer();
            updateUI();
            updateLiveStatsUI();
            initCrashChart();
        }
        
        function startRunTimer() {
            if (runTimerInterval) clearInterval(runTimerInterval);
            runTimerInterval = setInterval(() => {
                if (state.runActive && !state.isPaused) {
                    const elapsedSeconds = Math.floor((Date.now() - state.runStartTime - pausedTime) / 1000);
                    runTimeEl.textContent = formatTime(elapsedSeconds);
                    updateUI();
                }
            }, 1000);
        }
        
        function pauseRun() {
            if (state.isPaused) return;
            state.isPaused = true;
            timeAtPause = Date.now();
        }

        function resumeRun() {
            if (!state.isPaused) return;
            state.isPaused = false;
            pausedTime += Date.now() - timeAtPause;
        }

    // Account XP/level system replaces old firewall mechanic

        function placeBet() {
            if (state.gameInProgress) return;
            let betAmount = state.autoBet.isActive ? state.autoBet.currentBet : parseFloat(betAmountInput.value);

            if (betAmount > state.currentCash) {
                betAmount = state.currentCash;
                betAmountInput.value = betAmount.toFixed(2);
                 if (state.autoBet.isActive) {
                    gameMessageEl.textContent = "Not enough cash for auto bet. Stopping.";
                    stopAutoBet();
                    return;
                }
            }
            if (isNaN(betAmount) || betAmount <= 0) {
                gameMessageEl.textContent = "Invalid bet amount.";
                gameMessageEl.style.color = '#ef4444';
                if (state.autoBet.isActive) stopAutoBet();
                return;
            }

            state.currentBet = betAmount;
            state.currentRoundBet = betAmount; // lock the bet for this round
            state.currentCash -= betAmount;
            state.gameInProgress = true;
            gameMessageEl.textContent = `Bet of ${formatCurrency(betAmount, false)} placed.`;
            gameMessageEl.style.color = '#e2e8f0';
            
            state.runStats.overall.wagered += state.currentRoundBet;
            state.runStats[state.currentGame].wagered += state.currentRoundBet;
            
            if (state.currentGame === 'crash') startCrashGame();
            if (state.currentGame === 'limbo') startLimboGame();
            if (state.currentGame === 'mines') startMinesGame();
            if (state.currentGame === 'dice') startDiceGame();
            if (state.currentGame === 'blackjack') startBlackjackGame();
            if (state.currentGame === 'keno') startKenoGame();
            if (state.currentGame === 'slide') startSlideGame();
            
            updateUI();
        }

        function cashOut() {
            if (!state.gameInProgress) return;
            
            let winnings = 0;
            let roundBet = 0;
            let message = '';
            
            if (state.currentGame === 'crash') {
                roundBet = state.crash.roundBet || state.currentRoundBet;
                winnings = roundBet * state.crash.multiplier;
                message = `Cashed out for ${formatCurrency(winnings, false)}!`;
            } else if (state.currentGame === 'mines') {
                roundBet = state.mines.roundBet || state.currentRoundBet;
                winnings = roundBet * state.mines.payoutMultiplier;
                message = `Cashed out ${formatCurrency(winnings, false)} with ${state.mines.gemsFound} gems!`;
            } else {
                return; // Not a cash-outable game
            }
            
            gameMessageEl.textContent = message;
            handleWin(winnings, roundBet);
            gameMessageEl.style.color = '#4ade80';
            resetGameRound();
            updateUI();
        }

        function handleWin(winnings, betAmount) {
            const profit = winnings - betAmount;
            addResultToHistory(state.currentGame, { profit });
            state.currentCash += winnings;
            state.runStats.overall.wins++;
            state.runStats.overall.won += winnings;
            state.runStats[state.currentGame].wins++;
            state.runStats[state.currentGame].won += winnings;
            
            // Play win sound - use streak for games with streak mechanics
            let streak = 1;
            if (state.currentGame === 'mines' && state.mines.gemsFound) {
                streak = state.mines.gemsFound;
            }
            soundSystem.playWin(streak);
            
            state.runStats.cashHistory.push({ bet: state.runStats.overall.wins + state.runStats.overall.losses, cash: state.currentCash });
            updateLiveStatsUI();
            // award XP and show it under the money message
            const xp = awardXpForWin(winnings, betAmount) || 0;
            if (xp > 0 && xpMessageEl) {
                xpMessageEl.textContent = `+${xp} XP`;
                setTimeout(() => { xpMessageEl.textContent = '\u00A0'; }, 2000);
            }

            if (state.autoBet.isActive) {
                runNextAutoBet(true);
            }
        }

        function handleLoss(betAmount) {
            const profit = -betAmount;
            addResultToHistory(state.currentGame, { profit });
            
            // Play loss sound
            soundSystem.playLoss();

            if (state.currentGame === 'crash') {
                gameMessageEl.textContent = `Crashed at ${state.crash.crashPoint.toFixed(2)}x!`;
                multiplierEl.classList.add('text-red-500');
            }
            else if (state.currentGame === 'mines') {
                gameMessageEl.textContent = `You hit a mine!`;
                revealAllMines();
            }
            state.runStats.overall.losses++;
            state.runStats[state.currentGame].losses++;
            state.runStats.cashHistory.push({ bet: state.runStats.overall.wins + state.runStats.overall.losses, cash: state.currentCash });
            updateLiveStatsUI();
            gameMessageEl.style.color = '#ef4444';

            if (!['crash', 'mines'].includes(state.currentGame)) { // These games reset elsewhere
                 resetGameRound();
            }

            if (state.autoBet.isActive) {
                runNextAutoBet(false);
            }
            
            // Firewall check removed; runs no longer auto-end on firewall
            updateUI();
        }
        
        function resetGameRound() {
            clearTimeout(crashLoopInterval);
            state.gameInProgress = false;
            state.currentBet = 0;
            state.currentRoundBet = 0;
            state.crash.multiplier = 1.00;
            state.mines.gemsFound = 0;
            state.mines.payoutMultiplier = 1.0;
            state.blackjack.status = 'betting';
            if (state.crash) state.crash.roundBet = 0;
            if (state.mines) state.mines.roundBet = 0;
            if (state.blackjack) state.blackjack.roundBet = 0;
        }

        function endRun(wasBust = false) {
            if(state.autoBet.isActive) stopAutoBet();
            state.runActive = false;
            clearInterval(runTimerInterval);
            clearTimeout(crashLoopInterval);
            updateLifetimeStats();
            const score = wasBust ? 0 : state.currentCash;
            modalTitle.textContent = wasBust ? "Run Busted!" : "Run Complete!";
            modalMessage.textContent = wasBust 
                ? `Your run ended with a bust.`
                : "You successfully cashed out your run.";
            finalScore.textContent = formatCurrency(score, false);
            gameOverModal.classList.remove('hidden');
            gameOverModal.classList.add('flex');
            gameArea.classList.add('hidden');
        }

        // --- Game Specific Logic ---
        function createGradient(ctx, color) {
            const gradient = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);
            gradient.addColorStop(0, `${color}50`);
            gradient.addColorStop(1, `${color}00`);
            return gradient;
        }

        function initCrashChart() {
            if (crashChart) {
                crashChart.destroy();
            }
            const ctx = crashChartCanvas.getContext('2d');
            crashChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        data: [],
                        borderColor: '#e2e8f0',
                        backgroundColor: createGradient(ctx, '#e2e8f0'),
                        borderWidth: 3,
                        pointRadius: 0,
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { 
                            grid: { display: false, drawBorder: false },
                            ticks: {
                                color: '#94a3b8',
                                font: { size: 10 },
                                callback: function(value, index, values) {
                                    const label = this.getLabelForValue(value);
                                    if (parseFloat(label) % 1 === 0) return label + 's';
                                    return '';
                                },
                                maxRotation: 0, minRotation: 0, autoSkip: false
                            }
                        },
                        y: { 
                            beginAtZero: true,
                            grid: { color: 'rgba(51, 65, 85, 0.5)', drawBorder: false, },
                            ticks: {
                                color: '#94a3b8',
                                font: { size: 10 },
                                callback: function(value) { return value.toFixed(1) + 'x'; }
                            }
                        }
                    },
                    plugins: { legend: { display: false }, tooltip: { enabled: false } },
                    animation: { duration: 0 }
                }
            });
        }

        function startCrashGame() {
            state.crash.multiplier = 1.00;
            state.crash.startTime = Date.now();
            state.crash.roundBet = state.currentRoundBet;
            const r = Math.random();
            state.crash.crashPoint = Math.max(1.01, 1 / (1 - r));
            gameMessageEl.textContent = "Multiplier increasing...";

            crashChart.data.labels = [0];
            crashChart.data.datasets[0].data = [1];
            crashChart.data.datasets[0].borderColor = '#e2e8f0';
            crashChart.data.datasets[0].backgroundColor = createGradient(crashChart.ctx, '#e2e8f0');
            multiplierEl.className = 'multiplier-display text-slate-200';
            crashChart.update();

            const runGameLoop = () => {
                if (!state.gameInProgress) return;
                
                const elapsedTime = (Date.now() - state.crash.startTime) / 1000;
                state.crash.multiplier = Math.pow(1.07, elapsedTime);
                
                // Play the tick sound on each loop iteration
                soundSystem.playCrashTick(state.crash.multiplier);

                crashChart.data.labels.push(elapsedTime.toFixed(1));
                crashChart.data.datasets[0].data.push(state.crash.multiplier);
                
                let color = '#e2e8f0';
                if (state.crash.multiplier >= 10) color = '#ef4444';
                else if (state.crash.multiplier >= 5) color = '#f97316';
                else if (state.crash.multiplier >= 2) color = '#eab308';
                
                crashChart.data.datasets[0].borderColor = color;
                crashChart.data.datasets[0].backgroundColor = createGradient(crashChart.ctx, color);
                multiplierEl.style.color = color;
                
                crashChart.options.scales.y.max = Math.max(1.5, Math.ceil(state.crash.multiplier / 5) * 5);
                crashChart.update('none');

                if (state.crash.multiplier >= state.crash.crashPoint) {
                    handleLoss(state.crash.roundBet);
                    resetGameRound();
                    return;
                }
                
                const intervalTime = Math.max(10, 100 - (state.crash.multiplier * 1.5));
                crashLoopInterval = setTimeout(runGameLoop, intervalTime);
                
                updateUI();
            };

            runGameLoop();
        }

        function updateLimboUI() {
            const target = parseFloat(limboTargetInput.value);
            if (isNaN(target) || target < 1.01) {
                limboWinChanceEl.textContent = '0.00%';
                return;
            }
            state.limbo.target = target;
            const houseEdge = 0.99; // 1% house edge
            const winChance = (1 / target) * 100 * houseEdge;
            limboWinChanceEl.textContent = `${winChance.toFixed(2)}%`;
        }

        function startLimboGame() {
            const target = state.limbo.target;
            if (isNaN(target) || target < 1.01) {
                gameMessageEl.textContent = "Invalid target multiplier.";
                gameMessageEl.style.color = '#ef4444';
                state.gameInProgress = false;
                state.currentCash += state.currentRoundBet;
                return;
            }

            const result = 1 / (1 - Math.random());
            const roundBet = state.currentRoundBet;
            
            let currentDisplay = 1.00;
            const animationDuration = 800;
            const startTime = Date.now();

            const animateNumber = () => {
                const elapsedTime = Date.now() - startTime;
                if (elapsedTime >= animationDuration) {
                    limboResultDisplay.textContent = `${result.toFixed(2)}x`;
                    finishLimboGame(result, target, roundBet);
                    return;
                }
                
                const progress = elapsedTime / animationDuration;
                const easedProgress = 1 - Math.pow(1 - progress, 3);
                const newDisplay = 1 + (result - 1) * easedProgress;
                
                // Play tick sound if value changed significantly
                if (Math.floor(newDisplay * 20) > Math.floor(currentDisplay * 20)) {
                    soundSystem.playTick(newDisplay);
                }
                
                currentDisplay = newDisplay;
                limboResultDisplay.textContent = `${currentDisplay.toFixed(2)}x`;
                
                requestAnimationFrame(animateNumber);
            };

            limboResultDisplay.classList.remove('text-green-400', 'text-red-500');
            limboResultDisplay.classList.add('text-slate-200');
            requestAnimationFrame(animateNumber);
        }

    function finishLimboGame(result, target, roundBet) {
            const won = result >= target;
            if (won) {
                const winnings = roundBet * target;
                gameMessageEl.textContent = `You won ${formatCurrency(winnings, false)}!`;
                gameMessageEl.style.color = '#4ade80';
                limboResultDisplay.classList.remove('text-slate-200');
                limboResultDisplay.classList.add('text-green-400');
                handleWin(winnings, roundBet);
                limboResultDisplay.classList.remove('text-slate-200');
                limboResultDisplay.classList.add('text-green-400');
            } else {
                gameMessageEl.textContent = `You lost.`;
                gameMessageEl.style.color = '#ef4444';
                limboResultDisplay.classList.remove('text-slate-200');
                limboResultDisplay.classList.add('text-red-500');
                handleLoss(roundBet);
            }
            
            setTimeout(() => {
                if (!state.autoBet.isActive) { // only reset if not auto betting
                    resetGameRound();
                    updateUI();
                }
            }, 1500);
        }

        function startMinesGame() {
            const mineCount = parseInt(mineCountInput.value);
            if (isNaN(mineCount) || mineCount < 1 || mineCount > 24) {
                 gameMessageEl.textContent = "Invalid mine count (1-24).";
                 gameMessageEl.style.color = '#ef4444';
                 state.gameInProgress = false;
                 state.currentCash += state.currentRoundBet;
                 return;
            }
            state.mines.mineCount = mineCount;
            state.mines.gemsFound = 0;
            state.mines.payoutMultiplier = 1.0;
            state.mines.roundBet = state.currentRoundBet;
            generateMinesGrid();
            renderMinesGrid();
            gameMessageEl.textContent = `Find the gems. Avoid the ${mineCount} mines.`;
        }

        function generateMinesGrid() {
            const { rows, cols, mineCount } = state.mines;
            const totalTiles = rows * cols;
            state.mines.grid = Array(totalTiles).fill('gem');
            let minesPlaced = 0;
            while (minesPlaced < mineCount) {
                const index = Math.floor(Math.random() * totalTiles);
                if (state.mines.grid[index] !== 'mine') {
                    state.mines.grid[index] = 'mine';
                    minesPlaced++;
                }
            }
        }

        function renderMinesGrid() {
            minesGridEl.innerHTML = '';
            state.mines.grid.forEach((type, index) => {
                const tile = document.createElement('button');
                tile.classList.add('mine-tile');
                tile.dataset.index = index;
                tile.addEventListener('click', () => onMineTileClick(tile, index));
                minesGridEl.appendChild(tile);
            });
        }
        
        function onMineTileClick(tile, index) {
            if (!state.gameInProgress || tile.classList.contains('revealed')) return;
            tile.classList.add('revealed');
            if (state.mines.grid[index] === 'mine') {
                tile.classList.add('mine');
                tile.innerHTML = BOMB_SVG;
                handleLoss(state.mines.roundBet);
                resetGameRound();
            } else {
                tile.classList.add('gem');
                tile.innerHTML = '';
                state.mines.gemsFound++;
                // Play win sound for finding a gem, using gemsFound as streak
                soundSystem.playWin(state.mines.gemsFound);
                const totalTiles = state.mines.rows * state.mines.cols;
                const totalGems = totalTiles - state.mines.mineCount;
                
                let baseMultiplier;
                if (totalGems - state.mines.gemsFound <= 0) {
                    baseMultiplier = 25;
                } else {
                    baseMultiplier = (1 - state.mines.mineCount / totalTiles) * (totalTiles / (totalGems - state.mines.gemsFound));
                }

                if (state.mines.mineCount < 5) {
                    baseMultiplier = Math.max(0.1, baseMultiplier * 0.25);
                }

                state.mines.payoutMultiplier = baseMultiplier;

                gameMessageEl.textContent = `Found ${state.mines.gemsFound} gems! Payout: ${state.mines.payoutMultiplier.toFixed(2)}x`;
            }
            updateUI();
        }
        
        function revealAllMines() {
          const tiles = minesGridEl.children;
          state.mines.grid.forEach((type, index) => {
              if(type === 'mine' && !tiles[index].classList.contains('revealed')) {
                  tiles[index].classList.add('revealed', 'mine');
                  tiles[index].innerHTML = BOMB_SVG;
              }
          });
        }

        function updateDiceUI() {
            const sliderValue = parseInt(diceSlider.value);
            state.dice.target = sliderValue / 100;
            if (state.dice.betType === 'under') state.dice.winChance = state.dice.target;
            else state.dice.winChance = 100 - state.dice.target;
            if (state.dice.winChance <= 0) state.dice.winChance = 0.01;
            if (state.dice.winChance >= 100) state.dice.winChance = 99.99;
            const houseEdge = 0.975;
            state.dice.multiplier = (100 / state.dice.winChance) * houseEdge;
            diceMultiplierEl.textContent = `${state.dice.multiplier.toFixed(2)}x`;
            diceWinChanceEl.textContent = `${state.dice.winChance.toFixed(2)}%`;
            const betTypeText = state.dice.betType === 'under' ? 'Under' : 'Over';
            diceBetTypeBtn.textContent = `Roll ${betTypeText} ${state.dice.target.toFixed(2)}`;
            diceBetTypeBtn.classList.toggle('bg-green-600', state.dice.betType === 'under');
            diceBetTypeBtn.classList.toggle('bg-red-600', state.dice.betType === 'over');
        }

        function startDiceGame() {
            const roll = parseFloat((Math.random() * 100).toFixed(2));
            diceResultDisplay.textContent = roll;
            let won = (state.dice.betType === 'under' && roll < state.dice.target) || (state.dice.betType === 'over' && roll > state.dice.target);
            
            if (won) {
                const winnings = state.currentRoundBet * state.dice.multiplier;
                gameMessageEl.textContent = `You won ${formatCurrency(winnings, false)}!`;
                gameMessageEl.style.color = '#4ade80';
                diceResultDisplay.style.color = '#4ade80';
                handleWin(winnings, state.currentRoundBet);
            } else {
                gameMessageEl.textContent = `You lost.`;
                gameMessageEl.style.color = '#ef4444';
                diceResultDisplay.style.color = '#ef4444';
                handleLoss(state.currentRoundBet);
            }
            if(!state.autoBet.isActive) resetGameRound();
            updateUI();
        }

        function createDeck() {
            const suits = ['', '', '', ''];
            const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
            const deck = [];
            for (const suit of suits) {
                for (const rank of ranks) {
                    deck.push({ suit, rank });
                }
            }
            return deck;
        }

        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        function getCardValue(card) {
            if (['J', 'Q', 'K'].includes(card.rank)) return 10;
            if (card.rank === 'A') return 11;
            return parseInt(card.rank);
        }

        function calculateHandValue(hand) {
            let value = 0;
            let aceCount = 0;
            for (const card of hand) {
                value += getCardValue(card);
                if (card.rank === 'A') aceCount++;
            }
            while (value > 21 && aceCount > 0) {
                value -= 10;
                aceCount--;
            }
            return value;
        }

        function startBlackjackGame() {
            state.blackjack.deck = createDeck();
            shuffleDeck(state.blackjack.deck);
            state.blackjack.playerHand = [state.blackjack.deck.pop(), state.blackjack.deck.pop()];
            state.blackjack.dealerHand = [state.blackjack.deck.pop(), state.blackjack.deck.pop()];
            state.blackjack.status = 'playerTurn';
            renderBlackjackHands();
            state.blackjack.roundBet = state.currentRoundBet;
            const playerScore = calculateHandValue(state.blackjack.playerHand);
            if (playerScore === 21) {
                const winnings = state.blackjack.roundBet * 2.5; // 3:2 payout
                gameMessageEl.textContent = `Blackjack! You win ${formatCurrency(winnings, false)}!`;
                handleWin(winnings, state.blackjack.roundBet);
                setTimeout(resetGameRound, 1500);
            }
            updateUI();
        }

        function renderBlackjackHands(revealDealerCard = false) {
            playerHandEl.innerHTML = '';
            dealerHandEl.innerHTML = '';
            state.blackjack.playerHand.forEach(card => {
                playerHandEl.innerHTML += `<div class="card ${['', ''].includes(card.suit) ? 'red' : ''}">${card.rank}${card.suit}</div>`;
            });
            state.blackjack.dealerHand.forEach((card, index) => {
                if (index === 0 || revealDealerCard) {
                    dealerHandEl.innerHTML += `<div class="card ${['', ''].includes(card.suit) ? 'red' : ''}">${card.rank}${card.suit}</div>`;
                } else {
                    dealerHandEl.innerHTML += `<div class="card hidden"></div>`;
                }
            });
            state.blackjack.playerScore = calculateHandValue(state.blackjack.playerHand);
            playerScoreEl.textContent = state.blackjack.playerScore;
            if (revealDealerCard) {
                state.blackjack.dealerScore = calculateHandValue(state.blackjack.dealerHand);
                dealerScoreEl.textContent = state.blackjack.dealerScore;
            } else {
                dealerScoreEl.textContent = getCardValue(state.blackjack.dealerHand[0]);
            }
        }
        
        function blackjackHit() {
            if (state.blackjack.status !== 'playerTurn') return;
            state.blackjack.playerHand.push(state.blackjack.deck.pop());
            renderBlackjackHands();
            if (state.blackjack.playerScore > 21) {
                gameMessageEl.textContent = 'Bust! You lose.';
                handleLoss(state.blackjack.roundBet);
                setTimeout(resetGameRound, 1500);
            }
            updateUI();
        }

        function blackjackStand() {
            if (state.blackjack.status !== 'playerTurn') return;
            state.blackjack.status = 'dealerTurn';
            renderBlackjackHands(true);
            const dealerTurn = setInterval(() => {
                if (state.blackjack.dealerScore < 17) {
                    state.blackjack.dealerHand.push(state.blackjack.deck.pop());
                    renderBlackjackHands(true);
                } else {
                    clearInterval(dealerTurn);
                    endBlackjackHand();
                }
            }, 1000);
        }

        function endBlackjackHand() {
            renderBlackjackHands(true);
            const playerScore = state.blackjack.playerScore;
            const dealerScore = state.blackjack.dealerScore;
            const roundBet = state.blackjack.roundBet;
            if (dealerScore > 21 || playerScore > dealerScore) {
                const winnings = roundBet * 2;
                gameMessageEl.textContent = `You win ${formatCurrency(winnings, false)}!`;
                handleWin(winnings, roundBet);
            } else if (dealerScore > playerScore) {
                gameMessageEl.textContent = 'Dealer wins.';
                handleLoss(roundBet);
            } else {
                gameMessageEl.textContent = 'Push.';
                handleWin(roundBet, roundBet); // Return original bet, profit is 0
            }
            setTimeout(resetGameRound, 2000);
            updateUI();
        }

        // --- Keno Logic ---
        const KENO_PAYOUTS = {
            1: { 1: 3.8 },
            2: { 2: 15 },
            3: { 2: 2, 3: 45 },
            4: { 2: 1, 3: 5, 4: 120 },
            5: { 3: 2, 4: 20, 5: 450 },
            6: { 3: 1, 4: 10, 5: 100, 6: 1600 },
            7: { 3: 1, 4: 5, 5: 40, 6: 400, 7: 5000 },
            8: { 4: 2, 5: 15, 6: 150, 7: 1500, 8: 10000 },
            9: { 4: 1, 5: 10, 6: 80, 7: 800, 8: 4000, 9: 20000 },
            10: { 4: 1, 5: 5, 6: 40, 7: 200, 8: 1000, 9: 5000, 10: 50000 }
        };

        function renderKenoBoard() {
            kenoGridEl.innerHTML = '';
            for (let i = 1; i <= 40; i++) {
                const tile = document.createElement('div');
                tile.classList.add('keno-tile');
                tile.textContent = i;
                tile.dataset.number = i;
                if (state.keno.selectedNumbers.includes(i)) {
                    tile.classList.add('selected');
                }
                tile.addEventListener('click', () => onKenoTileClick(i));
                kenoGridEl.appendChild(tile);
            }
        }

        function onKenoTileClick(number) {
            if (state.gameInProgress) return;
            const { selectedNumbers } = state.keno;
            const index = selectedNumbers.indexOf(number);
            if (index > -1) {
                selectedNumbers.splice(index, 1);
            } else if (selectedNumbers.length < 10) {
                selectedNumbers.push(number);
            }
            renderKenoBoard();
            updateKenoPayouts();
        }

        function updateKenoPayouts() {
            const numSelected = state.keno.selectedNumbers.length;
            kenoPayoutsEl.innerHTML = `<h4 class="font-bold mb-1 text-center">Payouts (${numSelected} picks)</h4>`;
            if (numSelected > 0) {
                const payouts = KENO_PAYOUTS[numSelected];
                for (const hits in payouts) {
                    kenoPayoutsEl.innerHTML += `<div class="flex justify-between"><span>Hits: ${hits}</span><span class="font-semibold">${payouts[hits]}x</span></div>`;
                }
            }
        }

        function startKenoGame() {
            renderKenoBoard();

            if (state.keno.selectedNumbers.length === 0) {
                gameMessageEl.textContent = "Select at least one number.";
                gameMessageEl.style.color = '#ef4444';
                state.gameInProgress = false;
                state.currentCash += state.currentRoundBet;
                if(state.autoBet.isActive) stopAutoBet();
                return;
            }

            const allNumbers = Array.from({ length: 40 }, (_, i) => i + 1);
            const drawnNumbers = [];
            for (let i = 0; i < 10; i++) {
                const index = Math.floor(Math.random() * allNumbers.length);
                drawnNumbers.push(allNumbers.splice(index, 1)[0]);
            }

            const hits = state.keno.selectedNumbers.filter(n => drawnNumbers.includes(n));
            const numHits = hits.length;
            const numSelected = state.keno.selectedNumbers.length;
            const payoutsForSelection = KENO_PAYOUTS[numSelected] || {};
            const payoutMultiplier = payoutsForSelection[numHits] || 0;
            const roundBet = state.currentRoundBet;

            let i = 0;
            const drawInterval = setInterval(() => {
                const drawn = drawnNumbers[i];
                const tile = kenoGridEl.querySelector(`[data-number="${drawn}"]`);
                if (hits.includes(drawn)) {
                    tile.classList.add('hit');
                } else {
                    tile.classList.add('miss');
                }
                i++;
                if (i >= drawnNumbers.length) {
                    clearInterval(drawInterval);
                    if (payoutMultiplier > 0) {
                        const winnings = roundBet * payoutMultiplier;
                        gameMessageEl.textContent = `You hit ${numHits} numbers and won ${formatCurrency(winnings, false)}!`;
                        gameMessageEl.style.color = '#4ade80';
                        handleWin(winnings, roundBet);
                    } else {
                        gameMessageEl.textContent = `You hit ${numHits} numbers and lost.`;
                        gameMessageEl.style.color = '#ef4444';
                        handleLoss(roundBet);
                    }
                    setTimeout(() => {
                         if (!state.autoBet.isActive) {
                             resetGameRound();
                             updateUI();
                         }
                    }, 2000);
                }
            }, 100);
        }

        // --- Slide Logic ---
        function startSlideGame() {
            const risk = state.slide.risk;
            const possibleOutcomes = SLIDE_MULTIPLIERS[risk];
            const totalWeight = possibleOutcomes.reduce((sum, o) => sum + o.w, 0);

            const reelItems = [];
            for (let i = 0; i < 50; i++) {
                let random = Math.random() * totalWeight;
                for (const outcome of possibleOutcomes) {
                    if (random < outcome.w) {
                        reelItems.push(outcome);
                        break;
                    }
                    random -= outcome.w;
                }
            }
            
            const winningItem = reelItems[25];
            
            slideReel.innerHTML = '';
            reelItems.forEach(item => {
                const caseEl = document.createElement('div');
                caseEl.classList.add('slide-item', item.c);
                caseEl.textContent = `${item.m}x`;
                slideReel.appendChild(caseEl);
            });

            const containerWidth = slideReelContainer.offsetWidth;
            const itemWidth = 110; // 100px width + 10px margin
            const targetPos = (containerWidth / 2) - (itemWidth / 2) - (25 * itemWidth);
            
            const randomOffset = (Math.random() - 0.5) * (itemWidth * 0.8);
            
            slideReel.style.transition = 'none';
            slideReel.style.left = '0px';

            setTimeout(() => {
                slideReel.style.transition = 'left 4s cubic-bezier(0.25, 0.1, 0.25, 1)';
                slideReel.style.left = `${targetPos + randomOffset}px`;
            }, 100);

            setTimeout(() => {
                const multiplier = winningItem.m;
                const roundBet = state.currentRoundBet;
                if (multiplier > 0) {
                    const winnings = roundBet * multiplier;
                    gameMessageEl.textContent = `You won ${formatCurrency(winnings, false)}!`;
                    gameMessageEl.style.color = '#4ade80';
                    handleWin(winnings, roundBet);
                } else {
                    gameMessageEl.textContent = 'You lost.';
                    gameMessageEl.style.color = '#ef4444';
                    handleLoss(roundBet);
                }
                if (!state.autoBet.isActive) {
                    resetGameRound();
                    updateUI();
                }
            }, 4500);
        }

        // --- UI and Stats Logic ---
        function updateLiveStatsUI() {
            const { overall } = state.runStats;
            const profit = overall.won - overall.wagered;
            const totalBets = overall.wins + overall.losses;
            const winRate = totalBets > 0 ? (overall.wins / totalBets) * 100 : 0;
            liveProfit.textContent = formatCurrency(profit);
            liveProfit.style.color = profit >= 0 ? '#4ade80' : '#ef4444';
            liveBets.textContent = totalBets;
            liveWinRate.textContent = totalBets > 0 ? `${winRate.toFixed(2)}%` : 'N/A';
        }

        function renderStatsModal() {
            statsTableBody.innerHTML = '';
            const games = ['crash', 'limbo', 'mines', 'dice', 'blackjack', 'keno', 'slide', 'overall'];
            games.forEach(gameKey => {
                const stats = state.runStats[gameKey];
                if (!stats) return;
                const profit = stats.won - stats.wagered;
                const totalBets = stats.wins + stats.losses;
                const winRate = totalBets > 0 ? `${((stats.wins / totalBets) * 100).toFixed(2)}%` : 'N/A';
                const row = `<tr><td class="font-bold">${gameKey.charAt(0).toUpperCase() + gameKey.slice(1)}</td><td>${stats.wins} / ${stats.losses}</td><td>${winRate}</td><td style="color: ${profit >= 0 ? '#4ade80' : '#ef4444'}">${formatCurrency(profit)}</td><td>${formatCurrency(stats.wagered, false)}</td></tr>`;
                statsTableBody.innerHTML += row;
            });
            drawStatsGraph();
        }
        
        function drawStatsGraph() {
            const { cashHistory } = state.runStats;
            const canvas = statsGraphCanvas;
            const ctx = statsGraphCtx;
            const padding = 20;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (cashHistory.length < 2) return;
            const cashValues = cashHistory.map(p => p.cash);
            const minCash = Math.min(...cashValues);
            const maxCash = Math.max(...cashValues);
            const range = maxCash - minCash;
            const y_scale = range > 0 ? (canvas.height - padding * 2) / range : 0;
            const x_scale = (canvas.width - padding * 2) / (cashHistory.length - 1);
            ctx.beginPath();
            ctx.moveTo(padding, canvas.height - padding - (cashHistory[0].cash - minCash) * y_scale);
            for (let i = 1; i < cashHistory.length; i++) {
                ctx.lineTo(padding + i * x_scale, canvas.height - padding - (cashHistory[i].cash - minCash) * y_scale);
            }
            ctx.strokeStyle = '#4f46e5';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function updateUI() {
            if (!state.runActive) return;
            currentCashEl.textContent = formatCurrency(state.currentCash, false);
            // Update account UI
            if (state.account && state.account.username) {
                accountNameEl.textContent = state.account.username;
                accountLevelEl.textContent = `Level: ${state.account.level}`;
                const pct = state.account.xpInLevel / xpForLevel(state.account.level) * 100;
                accountXpBarEl.style.width = `${Math.min(100, Math.max(0, pct))}%`;
                accountXpTextEl.textContent = `XP: ${state.account.xp} (Next: ${xpForLevel(state.account.level)})`;
            } else {
                accountNameEl.textContent = 'Not logged in';
                accountLevelEl.textContent = 'Level: 0';
                accountXpBarEl.style.width = '0%';
                accountXpTextEl.textContent = 'XP: 0';
            }
            
            const isAutoBetting = state.autoBet.isActive;
            const controlsDisabled = state.gameInProgress || isAutoBetting;

            placeBetBtn.disabled = controlsDisabled;
            cashOutBtn.disabled = !state.gameInProgress || !['crash', 'mines'].includes(state.currentGame) || isAutoBetting;
            betAmountInput.disabled = controlsDisabled;
            mineCountInput.disabled = controlsDisabled;
            diceSlider.disabled = controlsDisabled;
            limboTargetInput.disabled = controlsDisabled;
            document.querySelectorAll('#autoBetControls input').forEach(el => el.disabled = isAutoBetting);
            
            blackjackControls.classList.toggle('hidden', state.currentGame !== 'blackjack' || state.blackjack.status !== 'playerTurn');
            
            if (state.currentGame === 'crash') {
                multiplierEl.textContent = `${state.crash.multiplier.toFixed(2)}x`;
            }

            placeBetBtn.classList.remove('hidden');
            cashOutBtn.textContent = 'Cash Out';
        }

        function switchGame(gameName) {
            if (state.gameInProgress || state.autoBet.isActive) return;
            state.currentGame = gameName;
            gameTabs.forEach(tab => tab.classList.toggle('active', tab.dataset.game === gameName));
            gameDisplays.forEach(display => display.classList.toggle('hidden', display.id !== `${gameName}Game`));
            
            limboControls.classList.toggle('hidden', gameName !== 'limbo');
            minesControls.classList.toggle('hidden', gameName !== 'mines');
            diceControls.classList.toggle('hidden', gameName !== 'dice');
            blackjackControls.classList.toggle('hidden', true); // Always hide on switch
            slideControls.classList.toggle('hidden', gameName !== 'slide');
            
            gameMessageEl.textContent = '\u00A0';
            if (gameName === 'limbo') updateLimboUI();
            if (gameName === 'dice') updateDiceUI();
            if (gameName === 'keno') {
                renderKenoBoard();
                updateKenoPayouts();
            }
            renderHistoryBar();
            updateUI();
        }
        
        // --- Live History Logic ---
        function addResultToHistory(game, result) {
            if (!state.history[game]) state.history[game] = [];
            state.history[game].unshift(result); // Add to the beginning
            if (state.history[game].length > 20) {
                state.history[game].pop(); // Keep it to 20 items
            }
            renderHistoryBar();
        }

        function renderHistoryBar() {
            const game = state.currentGame;
            const history = state.history[game];
            const container = document.getElementById(`${game}History`);
            if (!container) return;
            container.innerHTML = '';

            if (!history || history.length === 0) return;

            history.forEach(result => {
                const item = document.createElement('div');
                item.classList.add('history-item');
                item.classList.toggle('win', result.profit >= 0);
                item.classList.toggle('loss', result.profit < 0);
                item.textContent = formatCurrency(result.profit, true);
                container.appendChild(item);
            });
        }

        // Lifetime stats are stored per-account in state.account.lifetimeStats
        function updateLifetimeStats() {
            // Persist run stats into the current account's lifetimeStats
            if (!state.account || !state.account.username) return;
            if (!state.account.lifetimeStats) state.account.lifetimeStats = {};
            const games = ['overall', 'crash', 'limbo', 'mines', 'dice', 'blackjack', 'keno', 'slide'];
            games.forEach(gameKey => {
                const run = state.runStats[gameKey];
                if (!run) return;
                if (!state.account.lifetimeStats[gameKey]) state.account.lifetimeStats[gameKey] = createEmptyStats();
                const life = state.account.lifetimeStats[gameKey];
                life.wins += run.wins;
                life.losses += run.losses;
                life.wagered += run.wagered;
                life.won += run.won;
            });
            // also track totals on account
            state.account.totalRuns = (state.account.totalRuns || 0) + 1;
            saveAccount(state.account);
        }

        // --- Account & XP/Level System ---
        function xpForLevel(level) {
            // Exponential-ish growth: base 100 XP, grows by 1.5x per level
            return Math.floor(100 * Math.pow(1.5, level));
        }

        function loadAccount(username) {
            const key = `tag_account_${username}`;
            const raw = localStorage.getItem(key);
            if (raw) return JSON.parse(raw);
            return { username, xp: 0, level: 0, xpInLevel: 0 };
        }

        function saveAccount(account) {
            const key = `tag_account_${account.username}`;
            localStorage.setItem(key, JSON.stringify(account));
        }

        function computeLevelFromXp(totalXp) {
            let level = 0;
            let remaining = totalXp;
            while (remaining >= xpForLevel(level)) {
                remaining -= xpForLevel(level);
                level++;
                // safety cap to avoid infinite loops on bad data
                if (level > 10000) break;
            }
            return { level, xpInLevel: remaining };
        }

        function awardXpForWin(winnings, betAmount) {
            if (!state.account || !state.account.username) return;
            // XP award: base on profit ratio and bet size. Larger wins -> more xp.
            const profit = Math.max(0, winnings - betAmount);
            // scale: base 10 XP per dollar profit, with sqrt dampening and small floor
            const xpGained = Math.max(1, Math.floor(Math.sqrt(profit + 1) * 10));
            state.account.xp += xpGained;
            const oldLevel = state.account.level;
            const lvlInfo = computeLevelFromXp(state.account.xp);
            state.account.level = lvlInfo.level;
            state.account.xpInLevel = lvlInfo.xpInLevel;
            
            // No sound on level up anymore
            saveAccount(state.account);
            return xpGained;
        }

        // Login page elements
        const loginPage = document.getElementById('loginPage');
        const loginUsernameInput = document.getElementById('loginUsernameInput');
        const loginExistingBtn = document.getElementById('loginExistingBtn');
        const registerBtn = document.getElementById('registerBtn');

        function showStartScreenAfterLogin() {
            // hide login, show start screen
            loginPage.classList.add('hidden');
            startScreen.classList.remove('hidden');
            // store last used username
            if (state.account && state.account.username) localStorage.setItem('greed_last_account', state.account.username);
            updateUI();
        }

        loginExistingBtn.addEventListener('click', () => {
            const name = (loginUsernameInput.value || '').trim();
            if (!name) {
                gameMessageEl.textContent = 'Please enter a username to login.';
                gameMessageEl.style.color = '#ef4444';
                return;
            }
            // try load existing account
            const accKey = `tag_account_${name}`;
            const raw = localStorage.getItem(accKey);
            if (!raw) {
                gameMessageEl.textContent = `Account '${name}' not found. Use Register to create it.`;
                gameMessageEl.style.color = '#ef4444';
                return;
            }
            state.account = loadAccount(name);
            const lvlInfo = computeLevelFromXp(state.account.xp || 0);
            state.account.level = lvlInfo.level;
            state.account.xpInLevel = lvlInfo.xpInLevel;
            saveAccount(state.account);
            gameMessageEl.textContent = `Logged in as ${state.account.username}`;
            gameMessageEl.style.color = '#e2e8f0';
            showStartScreenAfterLogin();
        });

        registerBtn.addEventListener('click', () => {
            const name = (loginUsernameInput.value || '').trim();
            if (!name) {
                gameMessageEl.textContent = 'Please enter a username to register.';
                gameMessageEl.style.color = '#ef4444';
                return;
            }
            // create/overwrite account
            state.account = { username: name, xp: 0, level: 0, xpInLevel: 0 };
            saveAccount(state.account);
            localStorage.setItem('greed_last_account', name);
            gameMessageEl.textContent = `Registered and logged in as ${name}`;
            gameMessageEl.style.color = '#e2e8f0';
            showStartScreenAfterLogin();
        });

        function renderLifetimeStatsModal() {
            lifetimeStatsTableBody.innerHTML = '';
            if (!state.account || !state.account.username) {
                document.getElementById('accountSummaryBody').textContent = 'Not logged in';
                return;
            }
            const acct = state.account;
            document.getElementById('accountSummaryBody').innerHTML = `<div>Username: <strong>${acct.username}</strong></div><div>Level: <strong>${acct.level || 0}</strong></div><div>XP: <strong>${acct.xp || 0}</strong></div><div>Total Runs: <strong>${acct.totalRuns || 0}</strong></div>`;
            const games = ['crash', 'limbo', 'mines', 'dice', 'blackjack', 'keno', 'slide', 'overall'];
            const lifeStats = acct.lifetimeStats || {};
            games.forEach(gameKey => {
                const stats = lifeStats[gameKey] || createEmptyStats();
                const profit = stats.won - stats.wagered;
                const totalBets = stats.wins + stats.losses;
                const winRate = totalBets > 0 ? `${((stats.wins / totalBets) * 100).toFixed(2)}%` : 'N/A';
                const row = `<tr><td class="font-bold">${gameKey.charAt(0).toUpperCase() + gameKey.slice(1)}</td><td>${stats.wins} / ${stats.losses}</td><td>${winRate}</td><td style="color: ${profit >= 0 ? '#4ade80' : '#ef4444'}">${formatCurrency(profit)}</td><td>${formatCurrency(stats.wagered, false)}</td></tr>`;
                lifetimeStatsTableBody.innerHTML += row;
            });
        }
        
        // --- Auto Bet Logic ---
        function startAutoBet() {
            const auto = state.autoBet;
            auto.isActive = true;
            
            auto.baseBet = parseFloat(autoBetAmountInput.value) || 1.00;
            auto.currentBet = auto.baseBet;
            auto.numBets = parseInt(autoNumBetsInput.value) || 0;
            auto.onWinIncrease = parseFloat(autoOnWinValueInput.value) || 0;
            auto.onLossIncrease = parseFloat(autoOnLossValueInput.value) || 0;
            auto.resetOnWin = autoOnWinValueInput.value === '';
            auto.resetOnLoss = autoOnLossValueInput.value === '';
            auto.stopOnProfit = parseFloat(autoStopOnProfitInput.value) || 0;
            auto.stopOnLoss = parseFloat(autoStopOnLossInput.value) || 0;
            
            auto.betsMade = 0;
            auto.sessionStartCash = state.currentCash;
            auto.sessionProfit = 0;

            startAutoBetBtn.textContent = "Stop Auto Bet";
            startAutoBetBtn.classList.replace('btn-primary', 'btn-danger');
            gameMessageEl.textContent = 'Auto-betting started...';
            updateUI();
            
            placeBet();
        }
        
        function stopAutoBet() {
            state.autoBet.isActive = false;
            startAutoBetBtn.textContent = "Start Auto Bet";
            startAutoBetBtn.classList.replace('btn-danger', 'btn-primary');
            gameMessageEl.textContent = 'Auto-betting stopped.';
            updateUI();
        }

        function runNextAutoBet(wasWin) {
            const auto = state.autoBet;
            
            // 1. Update bet amount for next round
            if (wasWin) {
                if (auto.resetOnWin) auto.currentBet = auto.baseBet;
                else auto.currentBet *= (1 + auto.onWinIncrease / 100);
            } else { // wasLoss
                if (auto.resetOnLoss) auto.currentBet = auto.baseBet;
                else auto.currentBet *= (1 + auto.onLossIncrease / 100);
            }
            // ensure bet is not smaller than a cent
            auto.currentBet = Math.max(0.01, auto.currentBet);

            // 2. Update session stats
            auto.betsMade++;
            auto.sessionProfit = state.currentCash - auto.sessionStartCash;

            // 3. Check stop conditions
            if (!auto.isActive) return; // a game might have stopped it (e.g. keno)
            if (auto.numBets > 0 && auto.betsMade >= auto.numBets) {
                gameMessageEl.textContent = `Target number of bets (${auto.numBets}) reached.`;
                stopAutoBet();
                return;
            }
            if (auto.stopOnProfit > 0 && auto.sessionProfit >= auto.stopOnProfit) {
                gameMessageEl.textContent = `Profit target of ${formatCurrency(auto.stopOnProfit, false)} reached.`;
                stopAutoBet();
                return;
            }
             if (auto.stopOnLoss > 0 && auto.sessionProfit <= -auto.stopOnLoss) {
                gameMessageEl.textContent = `Loss limit of ${formatCurrency(auto.stopOnLoss, false)} reached.`;
                stopAutoBet();
                return;
            }
            
            // 4. Reset round and place next bet
            resetGameRound();
            updateUI(); // update UI before placing next bet
            setTimeout(placeBet, 500); // 500ms delay between bets
        }

        // --- Event Listeners ---
        gameTabs.forEach(tab => tab.addEventListener('click', () => switchGame(tab.dataset.game)));
        startRunBtn.addEventListener('click', initializeRun);
        placeBetBtn.addEventListener('click', placeBet);
        cashOutBtn.addEventListener('click', cashOut);
        endRunBtn.addEventListener('click', () => endRun(false));
        playAgainBtn.addEventListener('click', () => {
            startScreen.classList.remove('hidden');
            gameOverModal.classList.add('hidden');
            gameOverModal.classList.remove('flex');
        });
        diceSlider.addEventListener('input', updateDiceUI);
        limboTargetInput.addEventListener('input', updateLimboUI);
        diceBetTypeBtn.addEventListener('click', () => {
            state.dice.betType = state.dice.betType === 'under' ? 'over' : 'under';
            updateDiceUI();
        });
        viewStatsBtn.addEventListener('click', () => {
            pauseRun();
            renderStatsModal();
            statsModal.classList.remove('hidden');
            statsModal.classList.add('flex');
        });
        closeStatsBtn.addEventListener('click', () => {
            resumeRun();
            statsModal.classList.add('hidden');
            statsModal.classList.remove('flex');
        });
        hitBtn.addEventListener('click', blackjackHit);
        standBtn.addEventListener('click', blackjackStand);
        
        lifetimeStatsBtn.addEventListener('click', () => {
            pauseRun();
            renderLifetimeStatsModal();
            lifetimeStatsModal.classList.remove('hidden');
            lifetimeStatsModal.classList.add('flex');
        });
        closeLifetimeStatsBtn.addEventListener('click', () => {
            lifetimeStatsModal.classList.add('hidden');
            lifetimeStatsModal.classList.remove('flex');
        });

        slideRiskBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                if (state.gameInProgress) return;
                state.slide.risk = btn.dataset.risk;
                slideRiskBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });
        
        // Auto-Bet Listeners
        manualBetTab.addEventListener('click', () => {
            if(state.autoBet.isActive) return;
            manualBetTab.classList.add('active');
            autoBetTab.classList.remove('active');
            manualBetControls.classList.remove('hidden');
            autoBetControls.classList.add('hidden');
        });
        
        autoBetTab.addEventListener('click', () => {
            if(state.autoBet.isActive) return;
            autoBetTab.classList.add('active');
            manualBetTab.classList.remove('active');
            autoBetControls.classList.remove('hidden');
            manualBetControls.classList.add('hidden');
        });

        startAutoBetBtn.addEventListener('click', () => {
            if (state.autoBet.isActive) stopAutoBet();
            else startAutoBet();
        });
        
        autoResetOnWin.addEventListener('click', () => autoOnWinValueInput.value = '' );
        autoResetOnLoss.addEventListener('click', () => autoOnLossValueInput.value = '' );

    // Initial Load
        // Prefill last username in login box for convenience (do not auto-login)
        (function prefillLastAccount() {
            const last = localStorage.getItem('greed_last_account');
            if (last) {
                loginUsernameInput.value = last;
            }
        })();
        
    </script>
</body>
</html>
